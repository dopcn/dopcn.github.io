<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta property="og:image" content="https://og-image.vercel.app/Blog%20based%20on%20Next.js.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Blog based on Next.js"/><meta name="twitter:card" content="summary_large_image"/><link rel="preload" as="image" href="/images/profile.jpg"/><title>日常生活和编程中的相对关系和绝对关系</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/0275f6d90e7ad339.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0275f6d90e7ad339.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c39f9723b4064ac0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c39f9723b4064ac0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-7979c4ac9f7c3a8c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d42b1448b72664a1.js" defer=""></script><script src="/_next/static/chunks/247-36b39074e2867c87.js" defer=""></script><script src="/_next/static/chunks/358-14c60bb94e9d94b9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-865a221980b29041.js" defer=""></script><script src="/_next/static/FJCTT2WIUQORIXoq9PXPx/_buildManifest.js" defer=""></script><script src="/_next/static/FJCTT2WIUQORIXoq9PXPx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__fbLkO"><header class="layout_header__kY0Lt"><a href="/"><img alt="" src="/images/profile.jpg" width="108" height="108" decoding="async" data-nimg="1" class="utils_borderCircle__s2nTm" style="color:transparent"/></a><h2 class="utils_headingLg__5535D"><a class="utils_colorInherit__mSH_x" href="/">Dopcn</a></h2></header><main><article><h1 class="utils_headingXl__u25Y2">日常生活和编程中的相对关系和绝对关系</h1><div class="utils_lightText__eUzGY"><time dateTime="2015-11-28 ">November 28, 2015</time></div><div><blockquote>
<p>这个世界上所有事物都是相对的，只有「相对」本身是绝对的
<strong>接盘侠日记</strong></p>
</blockquote>
<h3>最屌文件命名</h3>
<p>曾经有一个合作的设计师出了一套新版本界面设计稿，她新建了一个文件夹打包上传到内部 GitLab repo ，我 pull 下来看到这个文件夹</p>
<p><img src="1.png" alt="image"></p>
<p>这是我目前看到过最屌的命名，于是我想下一个版本的设计稿文件夹她会起什么名字：「目前最最新的稿子」？「比目前最新的稿子更新的稿子」？「未来最新的稿子」？无论选择这其中的哪一种方案都会有一个共同特点，那就是下一次的起名都必须依赖于这一次的名字，以用来表明这个文件夹更新，而这种依赖是递增不可绕过的，比如说选用第一种方案那么到下下下下个版本就是「目前最最最最最最新的稿子」，以此类推这显然是一个灾难。当然实际中我们的设计师并不会这样，更常见的情况是下一次她的命名直接进入另一个次元，「稿子新」比「目前最新的稿子」更新，这样就可以区分出哪个更新，现在的使用者是清楚了可是接盘侠呢，果然光荣与伟大并不是那么得容易担当。</p>
<h3>绝对和相对</h3>
<p>当需要设定某种唯一标识的时候，绝对的概念能够更明确的定位。当需要描述一种关系的时候，相对的表述方法更加适合。</p>
<p>相对和绝对路径是一个直观的例子。</p>
<pre><code>/Users/fengweizhou/Documents/dopcnblog/source/_posts/absolute-vs-relativity.md
source/_posts/absolute-vs-relativity.md
</code></pre>
<p>绝对路径则是由根目录开始一层一层明确写出到达目标文件的完整路径。相对路径可以直接用文件名引入同一个文件夹中同级的文件，用 <code>../</code> 代表上一级目录。显然两种不同用法在不同的环境中各有优势，在决定使用哪一种用法之前能够明确区分两种方法的不同很重要。</p>
<h3>其他绝对和相对的例子</h3>
<h4>绝对和相对的界面构建</h4>
<p>界面布局的相对和绝对。在这个领域「相对」有压倒性的优势，在浏览器端响应式网页应该是如今网站建设的标配，除了流量特别大的网站可能会为了特别定制将移动端网页分出去。使用 CSS 进行网页布局可以分为三个阶段：手写 CSS -> 用 Sass 写 CSS -> 用 Sass 写 Flexbox。在阶段一是使用「绝对」的方式写 CSS，这样依然可以写出「相对」的布局</p>
<p>iOS 设备上的界面构建技术稍落后于前端不过遵循了同样的路径。从只有一种屏幕大小的时代手写固定的 CGRect，到在 Size Class 中建立 AutoLayout 约束规则，这样编写出的约束规则依然是绝对的，最后再到使用 UIStackView 布局减少了许多需要手动设置 AutoLayout 的步骤。对比最初的手写固定 CGRect 越来越相对。</p>
<h4>页面转换路径的相对绝对</h4>
<p>我之前合作的产品经理同时负责产品的网页端和客户端，所以可能就是因为这个原因在客户端的设计过程中页面转换逻辑几乎是按照网页端的来，网页端的页面转换是链接跳转，类似于利用指针访问可以任意跳转，相比之下客户端的页面转换逻辑大多时候是后进先出的栈结构。再加上以前页面转换逻辑的写法相对绝对</p>
<pre><code>let vc = SomeViewController()
navigationController?.pushViewController(vc, animated: true)
</code></pre>
<p>没少为设计方案来回讨论。后来为了为了尽可能适应这种网页端转换逻辑同时也扩大转换的自由度增加了URLTransformer 层，简单的原型：</p>
<pre><code>private protocol URLTransFormer {
    func canTransform(url: NSURL) -> Bool
    func transform(url: NSURL) -> UIViewController
}

//======================
//transformer list start

private struct Page1Transformer: URLTransFormer {
    func canTransform(url: NSURL) -> Bool {
        if url.scheme == "mydomain" {
            return true
        }
        return false
    }
    func transform(url: NSURL) -> UIViewController {
        return SomeViewController(url: url)
    }
}

//tranformer list end
//===================

struct URLTransformer {
    private let transformerList = [Page1Transformer()]
    func transform(url: NSURL) -> UIViewController? {
        for transformer in transformerList {
            if transformer.canTransform(url) {
                return transformer.transform(url)
            }
        }
        return nil
    }
}
</code></pre>
<p>这样页面转换逻辑就变成相对的，客户端同一个按钮可以根据服务器返回的链接形式打开不同的页面。这里服务器返回的链接一定要是绝对的完整路径，因为这个链接是在做一个唯一性的标识。</p>
<h4>描述一种相对的关系</h4>
<p>程序运行逻辑里有许多部分是要描述一种关系，例如注册页面在用户名密码通过格式验证之后提交按钮才可用</p>
<pre><code>import ReactiveUIKit
import ReactiveKit

……

combineLatest(usernameField.rText, passwordField.rText).map { username, password in
            guard let name = username, let pass = password else {
                return false
            }
            return name.characters.count > 7 &#x26;&#x26; pass.characters.count > 7
        }.bindTo(submitButton.rEnabled)

……

</code></pre>
<p>简单地使用用户名和密码都必须大于7位做验证条件，这个验证的 true false 和按钮 enable 状态的true false 之间是一种对应关系，如果用常用的赋值方法来每次改动这个值，可以想象条件分支会非常多，相对而言会不容易维护。这里直接描述对应关系使用的是第三方库 ReactiveKit，除了这个还有其他一些可以实现类似功能的库，不过达到的效果是类似的。</p>
</div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"absolute-vs-relativity","contentHtml":"\u003cblockquote\u003e\n\u003cp\u003e这个世界上所有事物都是相对的，只有「相对」本身是绝对的\n\u003cstrong\u003e接盘侠日记\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e最屌文件命名\u003c/h3\u003e\n\u003cp\u003e曾经有一个合作的设计师出了一套新版本界面设计稿，她新建了一个文件夹打包上传到内部 GitLab repo ，我 pull 下来看到这个文件夹\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e这是我目前看到过最屌的命名，于是我想下一个版本的设计稿文件夹她会起什么名字：「目前最最新的稿子」？「比目前最新的稿子更新的稿子」？「未来最新的稿子」？无论选择这其中的哪一种方案都会有一个共同特点，那就是下一次的起名都必须依赖于这一次的名字，以用来表明这个文件夹更新，而这种依赖是递增不可绕过的，比如说选用第一种方案那么到下下下下个版本就是「目前最最最最最最新的稿子」，以此类推这显然是一个灾难。当然实际中我们的设计师并不会这样，更常见的情况是下一次她的命名直接进入另一个次元，「稿子新」比「目前最新的稿子」更新，这样就可以区分出哪个更新，现在的使用者是清楚了可是接盘侠呢，果然光荣与伟大并不是那么得容易担当。\u003c/p\u003e\n\u003ch3\u003e绝对和相对\u003c/h3\u003e\n\u003cp\u003e当需要设定某种唯一标识的时候，绝对的概念能够更明确的定位。当需要描述一种关系的时候，相对的表述方法更加适合。\u003c/p\u003e\n\u003cp\u003e相对和绝对路径是一个直观的例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/Users/fengweizhou/Documents/dopcnblog/source/_posts/absolute-vs-relativity.md\nsource/_posts/absolute-vs-relativity.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e绝对路径则是由根目录开始一层一层明确写出到达目标文件的完整路径。相对路径可以直接用文件名引入同一个文件夹中同级的文件，用 \u003ccode\u003e../\u003c/code\u003e 代表上一级目录。显然两种不同用法在不同的环境中各有优势，在决定使用哪一种用法之前能够明确区分两种方法的不同很重要。\u003c/p\u003e\n\u003ch3\u003e其他绝对和相对的例子\u003c/h3\u003e\n\u003ch4\u003e绝对和相对的界面构建\u003c/h4\u003e\n\u003cp\u003e界面布局的相对和绝对。在这个领域「相对」有压倒性的优势，在浏览器端响应式网页应该是如今网站建设的标配，除了流量特别大的网站可能会为了特别定制将移动端网页分出去。使用 CSS 进行网页布局可以分为三个阶段：手写 CSS -\u003e 用 Sass 写 CSS -\u003e 用 Sass 写 Flexbox。在阶段一是使用「绝对」的方式写 CSS，这样依然可以写出「相对」的布局\u003c/p\u003e\n\u003cp\u003eiOS 设备上的界面构建技术稍落后于前端不过遵循了同样的路径。从只有一种屏幕大小的时代手写固定的 CGRect，到在 Size Class 中建立 AutoLayout 约束规则，这样编写出的约束规则依然是绝对的，最后再到使用 UIStackView 布局减少了许多需要手动设置 AutoLayout 的步骤。对比最初的手写固定 CGRect 越来越相对。\u003c/p\u003e\n\u003ch4\u003e页面转换路径的相对绝对\u003c/h4\u003e\n\u003cp\u003e我之前合作的产品经理同时负责产品的网页端和客户端，所以可能就是因为这个原因在客户端的设计过程中页面转换逻辑几乎是按照网页端的来，网页端的页面转换是链接跳转，类似于利用指针访问可以任意跳转，相比之下客户端的页面转换逻辑大多时候是后进先出的栈结构。再加上以前页面转换逻辑的写法相对绝对\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet vc = SomeViewController()\nnavigationController?.pushViewController(vc, animated: true)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e没少为设计方案来回讨论。后来为了为了尽可能适应这种网页端转换逻辑同时也扩大转换的自由度增加了URLTransformer 层，简单的原型：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprivate protocol URLTransFormer {\n    func canTransform(url: NSURL) -\u003e Bool\n    func transform(url: NSURL) -\u003e UIViewController\n}\n\n//======================\n//transformer list start\n\nprivate struct Page1Transformer: URLTransFormer {\n    func canTransform(url: NSURL) -\u003e Bool {\n        if url.scheme == \"mydomain\" {\n            return true\n        }\n        return false\n    }\n    func transform(url: NSURL) -\u003e UIViewController {\n        return SomeViewController(url: url)\n    }\n}\n\n//tranformer list end\n//===================\n\nstruct URLTransformer {\n    private let transformerList = [Page1Transformer()]\n    func transform(url: NSURL) -\u003e UIViewController? {\n        for transformer in transformerList {\n            if transformer.canTransform(url) {\n                return transformer.transform(url)\n            }\n        }\n        return nil\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样页面转换逻辑就变成相对的，客户端同一个按钮可以根据服务器返回的链接形式打开不同的页面。这里服务器返回的链接一定要是绝对的完整路径，因为这个链接是在做一个唯一性的标识。\u003c/p\u003e\n\u003ch4\u003e描述一种相对的关系\u003c/h4\u003e\n\u003cp\u003e程序运行逻辑里有许多部分是要描述一种关系，例如注册页面在用户名密码通过格式验证之后提交按钮才可用\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport ReactiveUIKit\nimport ReactiveKit\n\n……\n\ncombineLatest(usernameField.rText, passwordField.rText).map { username, password in\n            guard let name = username, let pass = password else {\n                return false\n            }\n            return name.characters.count \u003e 7 \u0026#x26;\u0026#x26; pass.characters.count \u003e 7\n        }.bindTo(submitButton.rEnabled)\n\n……\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e简单地使用用户名和密码都必须大于7位做验证条件，这个验证的 true false 和按钮 enable 状态的true false 之间是一种对应关系，如果用常用的赋值方法来每次改动这个值，可以想象条件分支会非常多，相对而言会不容易维护。这里直接描述对应关系使用的是第三方库 ReactiveKit，除了这个还有其他一些可以实现类似功能的库，不过达到的效果是类似的。\u003c/p\u003e\n","title":"日常生活和编程中的相对关系和绝对关系","date":"2015-11-28 ","category":"编程相关"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"absolute-vs-relativity"},"buildId":"FJCTT2WIUQORIXoq9PXPx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>