<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dopcn&#39;s Blog</title>
    <link>https://blog.fengweizhou.com/</link>
    <description>Recent content on Dopcn&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© Copyright dopcn</copyright>
    <lastBuildDate>Mon, 17 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.fengweizhou.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://blog.fengweizhou.com/about/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/about/</guid>
      <description>关于我 大学学习统计，毕业先干产品，至今从事开发</description>
    </item>
    
    <item>
      <title>我的 iOS 开发之路（一）</title>
      <link>https://blog.fengweizhou.com/posts/my-ios-1/</link>
      <pubDate>Thu, 24 May 2018 00:27:27 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/my-ios-1/</guid>
      <description>入门 iOS 开发需要掌握的东西有三个：一门语言、一个系统 SDK 和一个开发工具
语言 严格来说可以直接与系统 SDK 交互的语言有两个，分别是从最初就一直用的 Objc 和新起之秀 Swift。编程语言本身是一个大领域，聚焦到 iOS 开发特别是入门 iOS 开发，只需要先掌握 Objc 的用法。</description>
    </item>
    
    <item>
      <title>在 Mac 系统使用launchd运行定时任务</title>
      <link>https://blog.fengweizhou.com/posts/mac-launchd/</link>
      <pubDate>Sun, 04 Jun 2017 20:44:09 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/mac-launchd/</guid>
      <description>除了工作里，生活中也有很多重复的任务。比如说定期查询户口办理状态，尽可能第一时间去办理下一步。所以需要有一种方法可以定时跑一个脚本去爬取查询网站，解析结果最后通知自己。在 Mac 上可以用 launchd。
在操作系统中除了我们手动打开关闭的应用程序，还有一类后台常驻的进程，叫做 service 或者 daemon，大部分系统服务都是常驻的，在命令行中通过 launchctl list 查看，大部分是以 com.</description>
    </item>
    
    <item>
      <title>我的 GCD 回顾</title>
      <link>https://blog.fengweizhou.com/posts/grand-central-dispatch/</link>
      <pubDate>Tue, 21 Mar 2017 01:05:02 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/grand-central-dispatch/</guid>
      <description>入门 GCD 对我来说是初入门 iOS 开发的记忆，那个时候还不知道 UIKit 中的类应该在主线程调用，所以异步获取了数据之后虽然调用了 reloadData，但是界面怎么都不刷新，心慌慌查了好久才解决这个问题，现在回想起来也是蛮有趣。这可以说明 GCD 的引入，真的大大降低了进行多线程操作的门槛，然而要解决多线程带来的难题却依旧不那么容易。</description>
    </item>
    
    <item>
      <title>我的 Vim 使用日常</title>
      <link>https://blog.fengweizhou.com/posts/myvim/</link>
      <pubDate>Sun, 19 Feb 2017 23:39:10 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/myvim/</guid>
      <description>原生 vim 需要的配置不少，而且想要有一些特定自动补全需要的配置步骤就更多（iOS API），所以我主要是用 vim mode 插件。几乎主流的 IDE 应该都有 vim 插件，甚至 sublime text 都有 vim mode 可以开启。</description>
    </item>
    
    <item>
      <title>函数式与过程式编程区别之不同的世界观</title>
      <link>https://blog.fengweizhou.com/posts/different-world/</link>
      <pubDate>Thu, 10 Dec 2015 00:57:24 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/different-world/</guid>
      <description>大名鼎鼎的 objc.io 有一本书叫做 Functional Swift，只看到这个名字很容易误导人以为 Swift 可以是 Functional 的，但事实上这压根不可能，那本书更准确的名称应该是 Functional part of Swift。一个过程式语言可以拥有函数式的功能，特别是一些比较新的语言 Python Ruby 就曾经因为带有这些功能让人觉得更高级，同时也会被一些人评价说他们只不过实现了一些古老语言早就有的功能。这个评价是客观事实，早期从理论研究中诞生的编程语言大多都很函数式，局部变量和赋值这种过程式的功能仅仅是他们的一小部分。大规模应用于实践之后诞生的编程语言则完全将这一局面翻转了过来，完全是建立在局部变量和赋值之上的过程式，慢慢发展之后才开始增加一些函数式的功能。</description>
    </item>
    
    <item>
      <title>用高阶函数解八皇后问题</title>
      <link>https://blog.fengweizhou.com/posts/nqueensproblem/</link>
      <pubDate>Sat, 05 Dec 2015 15:50:16 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/nqueensproblem/</guid>
      <description>八皇后问题是求在八行八列的国际象棋棋盘上放置八个皇后，令她们彼此之间不能相互被吃的所有方法。国际象棋中皇后可以顺着横竖对角线方向行进任意距离。
高阶函数是泛指那些以一个函数（或者称之为一个过程）作为参数的函数，这个问题里用到的标准库里自带的 map flatmap filter reduce
在函数式编程思路中高阶函数在建立抽象和模块化过程中起到了很重要的作用，以 map 为例它将对一个序列的操作抽象出来，使序列本身和对序列的操作分割开来，这样做的好处是方便重用这种操作，也方便更换序列所需要进行的操作，为了实现这两点在常用的命令式写法中都是要整个操作重写才能完成。
高阶函数的组合使用可以更好的体现模块化的思想，高阶函数本身是模块与模块之间的接口，例如得到一个序列中的偶数的平方的序列：</description>
    </item>
    
    <item>
      <title>日常生活和编程中的相对关系和绝对关系</title>
      <link>https://blog.fengweizhou.com/posts/absolute-vs-relativity/</link>
      <pubDate>Sat, 28 Nov 2015 11:14:46 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/absolute-vs-relativity/</guid>
      <description>这个世界上所有事物都是相对的，只有「相对」本身是绝对的 &amp;mdash;&amp;mdash;接盘侠日记
最屌文件命名 曾经有一个合作的设计师出了一套新版本界面设计稿，她新建了一个文件夹打包上传到内部 GitLab repo ，我 pull 下来看到这个文件夹
这是我目前看到过最屌的命名，于是我想下一个版本的设计稿文件夹她会起什么名字：「目前最最新的稿子」？「比目前最新的稿子更新的稿子」？「未来最新的稿子」？无论选择这其中的哪一种方案都会有一个共同特点，那就是下一次的起名都必须依赖于这一次的名字，以用来表明这个文件夹更新，而这种依赖是递增不可绕过的，比如说选用第一种方案那么到下下下下个版本就是「目前最最最最最最新的稿子」，以此类推这显然是一个灾难。当然实际中我们的设计师并不会这样，更常见的情况是下一次她的命名直接进入另一个次元，「稿子新」比「目前最新的稿子」更新，这样就可以区分出哪个更新，现在的使用者是清楚了可是接盘侠呢，果然光荣与伟大并不是那么得容易担当。</description>
    </item>
    
    <item>
      <title>一些有趣的问题在Swift中的表现</title>
      <link>https://blog.fengweizhou.com/posts/some-special-cases-in-swift/</link>
      <pubDate>Mon, 23 Nov 2015 13:30:35 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/some-special-cases-in-swift/</guid>
      <description>1. 排序过的数组遍历更快 实验
let sorted = [false, true] for isSorted in sorted { var datas = Array(count: 32768, repeatedValue: 0).</description>
    </item>
    
    <item>
      <title>函数式与过程式编程区别之赋值行为</title>
      <link>https://blog.fengweizhou.com/posts/middle-status/</link>
      <pubDate>Wed, 18 Nov 2015 13:03:37 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/middle-status/</guid>
      <description>对于常见的过程式编程语言赋值行为和定义变量是同一种形式，都是用等号进行。对于函数式编程语言来说定义和赋值有着显著区别。
由于过程式编程更”容易”进行赋值所以经常采用在整个作用过程中使用起记录作用的状态变量，用一个获取 Fibonacci 前N 项中偶数的函数做示例：
func evenFibs1(n: Int) -&amp;gt; Array&amp;lt;Int&amp;gt; { var result = Array&amp;lt;Int&amp;gt;() var x = 0, y = 1, count = n result.</description>
    </item>
    
    <item>
      <title>复合数据分层设计求数独解的例子</title>
      <link>https://blog.fengweizhou.com/posts/solve-sudoku/</link>
      <pubDate>Fri, 13 Nov 2015 23:26:19 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/solve-sudoku/</guid>
      <description>由编程语言自带的数据结构种类有限，在解决实际问题中设计适和的复合数据类型更有利于程序的组织和迭代。复合数据的分层设计一般可以分为三层：最底层是复合数据的实现，上层是复合数据的使用方法，最上层是复合数据使用方法的应用。
在这个例子中，最底层使用数组作为数独数据的实现，在上层使用 struct 的初始化函数、subscript 中的 getter 和 setter，最后基于getter和setter实现数独求解的各个步骤。
enum SudokuError: ErrorType { case initDataError case invalidSudoku case subscriptOutOfRange } struct Sudoku: CustomStringConvertible { private var data = Array&amp;lt;Int&amp;gt;() init(array: Array&amp;lt;Int&amp;gt;) throws { guard array.</description>
    </item>
    
    <item>
      <title>过程数据二元对立之用过程复合数据</title>
      <link>https://blog.fengweizhou.com/posts/church-numerals/</link>
      <pubDate>Thu, 12 Nov 2015 12:34:05 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/church-numerals/</guid>
      <description>复合数据只要拥有满足一定条件的构造函数、选择函数和约束规则，甚至不需要是由基本数据复合，church 计数是一个以 lambda 表达式为唯一元素，构建数值、数值运算等编程要素的系统，在church 计数中 0 和 加1 运算分别被定义为
func zero&amp;lt;T&amp;gt;(f:(T-&amp;gt;T)) -&amp;gt; T-&amp;gt;T { return {x in return x} } func add_1&amp;lt;T&amp;gt;(n:(T-&amp;gt;T) -&amp;gt; T-&amp;gt;T) -&amp;gt; (T-&amp;gt;T) -&amp;gt; T-&amp;gt;T { return {f in return {x in return f(n(f)(x)) } } } 0 是一个以函数为参数返回一个函数的过程，加1 运算是作用于类似 0 这样的过程之上返回一个新过程的函数，将 0 带入 加1 运算得到 1 的定义，带入 1 得到 2 的定义</description>
    </item>
    
    <item>
      <title>数据过程二元对立之过程作为数据</title>
      <link>https://blog.fengweizhou.com/posts/procedure-abstraction/</link>
      <pubDate>Mon, 09 Nov 2015 22:54:21 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/procedure-abstraction/</guid>
      <description>3）将有关认识与那些在实际中和他同在的所有其他认识隔离开，这就是抽象 SICP 第一章 现存的许多威力强大的程序设计技术，都依赖于填平在「被动的」数据和「主动的」过程之间的传统划分 SICP 第一章
 计算机程序是由需要被操作的「数据」和操作数据的「过程」构成。解释起来可以说是一静一动，数据所代表的静态的具体某个值，而过程则是动态的代表从一个值到另一个值的转化。和数学研究很像不光研究函数对值的作用，还研究函数本身，计算机编程过程中也不光用过程作用于数据，也可以处理过程本身就像作用于数据之上那样。
过程作为参数 通过区间折半寻找方程的一个根</description>
    </item>
    
    <item>
      <title>递归、动态规划和迭代</title>
      <link>https://blog.fengweizhou.com/posts/recursion/</link>
      <pubDate>Mon, 02 Nov 2015 00:59:06 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/recursion/</guid>
      <description>每一个计算机程序都是现实中或者精神中的某一个过程的一个模型 SICP 序 在这一层次的课程里，最基本的材料并不是特定的程序设计语言语法，不是有效计算某种功能的巧妙算法，也不是算法的数学分析或者计算的本质，而是一些能够用于控制大型软件系统的智力复杂性的技术 SICP 前言
 计算机程序中对象可以大体分为两类：数据和过程。数据是那些需要去操作的东西，过程则是具体操作的指令。要求解复合过程的结果需要先得到子过程的结果，求子过程的结果需要得到子过程的子过程的结果，一次类推直到某一层子过程是最基本的表达式得到求值结果，这就是递归。
递归的简单应用，欧几里得算法求最大公约数 func gcd(x x: Int, y: Int) -&amp;gt; Int { if y == 0 { return x } else { return gcd(x: y, y: x%y) } } Fibonacci 数列求值 Fibonacci 数列的定义本身就是递归的，可以很自然的写成：</description>
    </item>
    
    <item>
      <title>有关动力的思考</title>
      <link>https://blog.fengweizhou.com/posts/motivation-pattern/</link>
      <pubDate>Fri, 23 Oct 2015 10:41:35 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/motivation-pattern/</guid>
      <description>缘起 可能和许多人一样我也有一些曾经想要学习然而却最终没有去进行学习的目标，需要举起例子的话很容易，不过我更想弄明白的是这些例子背后共通的原因。这就引发了我对动力的思考。
什么是动力？ 首先先建立一个认识模型：
 一个人的精神活动由两部分组成：一是由大脑皮层控制的理性，二是由大脑内部脑干等控制的感性。
 简单的对这两个组成部分进行一个解释：
理性，是一个人在后天的生活环境中通过社会环境的潜移默化和自己的主动学习培养起来的用于控制自己的一种能力，比如各种道德观念，有的时候可以称之为意识。
感性，是一个人继承自生物本能的应对外界刺激的能力，比如情绪，也可以称之为潜意识，但我理解这里所使用的潜字并不是隐藏起来的意思，而是虽然知道他的存在却不能直接操纵的意思。</description>
    </item>
    
    <item>
      <title>Git hooks 的几个用例</title>
      <link>https://blog.fengweizhou.com/posts/githooks/</link>
      <pubDate>Tue, 22 Sep 2015 00:02:37 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/githooks/</guid>
      <description>自动化是提高开发效率的有效手段之一。在源码管理过程中要实现自动化，必须能够知道源码管理工具内部的事件进行状态，显然对于这些独立工具是没办法像在同一个程序中一样进行类似 KVO 式的外部监听，好在 Git 就像一个设计完备的库一样提供了部分关键流程的调用接口，也就是 githooks。
将要处理的情景是在使用 Git 做版本管理，用 Cocoapods 进行第三方库管理的项目中</description>
    </item>
    
    <item>
      <title>为什么数组下标从0开始</title>
      <link>https://blog.fengweizhou.com/posts/why-array-start-from-0/</link>
      <pubDate>Tue, 21 Jul 2015 21:13:44 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/why-array-start-from-0/</guid>
      <description>从0开始记数经常被作为一个人是一名程序员的象征，在大多数主流编程语言中数组的记数都是以0为首位，今天读了 Dijkstra 的一篇旧文结合我的理解来谈谈为什么数组记数从0开始。
首先使用 0 作为数组第一位并不一定是一个正确的做法， 事实上也有以 1 作为首位的编程语言存在（Matlab，Fortran， Lua等），在 Dijkstra 的文章里他提出的证明思路是这样的：为表示一段离散的自然数集合例如 [4, 5, 6] 可以使用的公式有四种： a.</description>
    </item>
    
    <item>
      <title>做产品的一年</title>
      <link>https://blog.fengweizhou.com/posts/one-year-as-pm/</link>
      <pubDate>Sun, 21 Dec 2014 21:02:34 +0000</pubDate>
      
      <guid>https://blog.fengweizhou.com/posts/one-year-as-pm/</guid>
      <description>2013年7月我毕业，开始从事一个叫做产品助理的工作，在一家互联网公司。2013年是产品这个概念最疯传的一年，那一年所有人都在谈论张小龙的产品理念，那一年所有人都要跟你谈用户体验。疯传的背后有产业真实的发展与前进，也有互联网时代典型的一哄而上。这一年我学到的：
1. 小心在讨论中用到用户体验这个词的人 在产品讨论中直接用到用户体验这个词的人是典型的一哄而上的人，就好像有人跟你说：这个问题我们可以用大数据的方法解决一样，当他说出这种词的时候就已经暴露了他的无知，无论这种无知是有意还是无意的，小心总是没有错的。我知道这种无知再更多的场合和情景下可能是常态和客观现实，但毕竟现实是值得被讽刺得这也是客观现实。
2. 没有量化的标准无法做有效的决定 在这一年的工作当中，在产品方面给我收获最大是参加公司里的一个新技术应用比赛，在这个比赛中我主导了一个产品从创意产生到原型上线的整个过程，我们有4个团队成员，当时的工作分别是2个产品1个技术1个测试，报名和队伍的组织者是我。按照比赛的进程说说每个阶段的收获：
a. 团队内部确定方向 团队内部的决策过程是很典型的，我不主导我不说话，所以主导确定下来方向并不难</description>
    </item>
    
  </channel>
</rss>